CREATE EXTENSION IF NOT EXISTS CITEXT;
CREATE EXTENSION IF NOT EXISTS CUBE;
CREATE EXTENSION IF NOT EXISTS EARTHDISTANCE;

CREATE DOMAIN T_EMAIL AS CITEXT CHECK (
    VALUE ~* $$^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$$
);

CREATE TYPE T_GENDER AS ENUM('male', 'female', 'nonbinary');

CREATE TYPE T_ORIENTATION AS ENUM(
	'straight',
	'gay',
	'lesbian',
	'bisexual',
	'asexual',
	'demisexual',
	'pansexual',
	'queer',
	'questioning'
);

CREATE TYPE T_REPORT_REASON AS ENUM(
	'spam', 'harassment', 'fake_profile', 'inappropriate_content', 'scam', 'impersonation', 'hate_speech', 'discrimination', 'threats', 'violence', 'nudity', 'self_harm', 'underage_user', 'bullying', 'misleading_information', 'offensive_language', 'other'
);

CREATE TYPE T_REPORT_STATUS AS ENUM('under_review', 'dismissed', 'action_taken');
CREATE TYPE T_SWIPE_TYPE AS ENUM('like', 'dislike');
CREATE TYPE T_MESSAGE_TYPE AS ENUM ('text', 'image', 'audio', 'video');

CREATE OR REPLACE FUNCTION CHECK_AGE () RETURNS TRIGGER AS $$
BEGIN
    IF NEW.BIRTH_DATE IS NOT NULL AND NEW.BIRTH_DATE > (CURRENT_DATE - INTERVAL '18 years') THEN
        RAISE EXCEPTION 'User must be at least 18 years old.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION TRIM_USER_STRINGS () RETURNS TRIGGER AS $$
BEGIN
    IF NEW.email IS NOT NULL THEN NEW.email := trim(NEW.email); END IF;
    IF NEW.full_name IS NOT NULL THEN NEW.full_name := trim(NEW.full_name); END IF;
    IF NEW.bio IS NOT NULL THEN NEW.bio := trim(NEW.bio); END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TABLE IF NOT EXISTS USERS (
	USER_ID UUID PRIMARY KEY DEFAULT GEN_RANDOM_UUID(),
	EMAIL T_EMAIL NOT NULL UNIQUE,
	PASSWORD_HASH VARCHAR(255) NOT NULL,
	FULL_NAME VARCHAR(255) CHECK (LENGTH(FULL_NAME) > 0),
	GENDER T_GENDER,
	SEXUAL_ORIENTATION T_ORIENTATION,
	BIRTH_DATE DATE,
	BIO VARCHAR(512) NOT NULL DEFAULT '',
	CREATED_AT TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
	LATITUDE NUMERIC(9, 6) CHECK (LATITUDE BETWEEN -90 AND 90),
	LONGITUDE NUMERIC(9, 6) CHECK (LONGITUDE BETWEEN -180 AND 180),
	PREF_GENDERS T_GENDER[],
	PREF_MIN_AGE SMALLINT NOT NULL DEFAULT 18 CHECK (PREF_MIN_AGE BETWEEN 18 AND 200),
	PREF_MAX_AGE SMALLINT NOT NULL DEFAULT 200 CHECK (PREF_MAX_AGE BETWEEN 18 AND 200),
	PREF_DISTANCE_RADIUS_KM SMALLINT NOT NULL DEFAULT 10 CHECK (PREF_DISTANCE_RADIUS_KM BETWEEN 0 AND 20000),
	IS_ACTIVE BOOLEAN NOT NULL DEFAULT TRUE,
	IS_ONBOARDED BOOLEAN NOT NULL DEFAULT FALSE,
	IS_VERIFIED BOOLEAN NOT NULL DEFAULT FALSE,
	ALLOW_MESSAGES_FROM_STRANGERS BOOLEAN NOT NULL DEFAULT FALSE,
	CHECK (PREF_MIN_AGE <= PREF_MAX_AGE)
);

ALTER TABLE USERS ADD CONSTRAINT CHK_ONBOARDING_REQUIREMENTS CHECK (
    IS_ONBOARDED = FALSE OR (
        FULL_NAME IS NOT NULL AND
        GENDER IS NOT NULL AND 
        SEXUAL_ORIENTATION IS NOT NULL AND 
        BIRTH_DATE IS NOT NULL AND 
        PREF_GENDERS IS NOT NULL
    )
);

CREATE VIEW SAFE_USERS_PERSONAL AS
SELECT
	USER_ID, EMAIL, FULL_NAME, GENDER, SEXUAL_ORIENTATION, BIRTH_DATE, BIO, CREATED_AT, PREF_GENDERS, PREF_MIN_AGE, PREF_MAX_AGE, PREF_DISTANCE_RADIUS_KM, IS_ACTIVE, IS_ONBOARDED, IS_VERIFIED, ALLOW_MESSAGES_FROM_STRANGERS
FROM USERS;

CREATE VIEW SAFE_USERS_PUBLIC AS
SELECT
	USER_ID, FULL_NAME, EXTRACT(YEAR FROM AGE(BIRTH_DATE)) AS AGE, BIO, ALLOW_MESSAGES_FROM_STRANGERS
FROM USERS;

CREATE TRIGGER TRG_CHECK_AGE BEFORE INSERT OR UPDATE ON USERS FOR EACH ROW EXECUTE FUNCTION CHECK_AGE ();
CREATE TRIGGER TRG_TRIM_USER_STRINGS BEFORE INSERT OR UPDATE ON USERS FOR EACH ROW EXECUTE FUNCTION TRIM_USER_STRINGS ();

CREATE TABLE IF NOT EXISTS USER_CREDENTIALS (
    USER_ID UUID PRIMARY KEY REFERENCES USERS(USER_ID) ON DELETE CASCADE,
    VERIFICATION_CODE VARCHAR(6),
    RESET_TOKEN VARCHAR(255) UNIQUE,
    RESET_EXPIRES TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS USER_OAUTH (
    OAUTH_ID UUID PRIMARY KEY DEFAULT GEN_RANDOM_UUID(),
    USER_ID UUID NOT NULL REFERENCES USERS(USER_ID) ON DELETE CASCADE,
    PROVIDER VARCHAR(20) NOT NULL,
    PROVIDER_USER_ID VARCHAR(255) NOT NULL,
    UNIQUE(PROVIDER, PROVIDER_USER_ID)
);

CREATE TABLE IF NOT EXISTS REPORTS (
	REPORT_ID UUID PRIMARY KEY DEFAULT GEN_RANDOM_UUID(),
	REPORTER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	REPORTED_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	REASON T_REPORT_REASON NOT NULL,
	DETAILS VARCHAR(512) NOT NULL CHECK (LENGTH(DETAILS) > 10),
	STATUS T_REPORT_STATUS NOT NULL DEFAULT 'under_review'
);

CREATE TABLE IF NOT EXISTS BLOCKS (
	BLOCKER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	BLOCKED_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	BLOCKED_AT TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
	PRIMARY KEY (BLOCKER_ID, BLOCKED_ID),
	CHECK (BLOCKER_ID <> BLOCKED_ID)
);

CREATE TABLE IF NOT EXISTS LOGINS (
	LOGIN_ID BIGSERIAL PRIMARY KEY,
	USER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	IP_ADDRESS INET NOT NULL,
	LOGGED_IN_AT TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS MESSAGES (
	MESSAGE_ID UUID PRIMARY KEY DEFAULT GEN_RANDOM_UUID(),
	SENDER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	RECEIVER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
    MESSAGE_TYPE T_MESSAGE_TYPE NOT NULL DEFAULT 'text',
	MESSAGE_CONTENT VARCHAR(1024) NOT NULL DEFAULT '',
	IS_READ BOOLEAN NOT NULL DEFAULT FALSE,
	IS_DELETED BOOLEAN NOT NULL DEFAULT FALSE,
	SENT_AT TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
	CHECK (SENDER_ID <> RECEIVER_ID)
);

CREATE OR REPLACE FUNCTION TRIM_INTEREST_NAME () RETURNS TRIGGER AS $$
BEGIN
    IF NEW.interest_name IS NOT NULL THEN NEW.interest_name := trim(NEW.interest_name); END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TABLE IF NOT EXISTS INTERESTS (
    INTEREST_ID SERIAL PRIMARY KEY,
    INTEREST_NAME CITEXT NOT NULL UNIQUE CHECK (
        LENGTH(INTEREST_NAME) >= 2 AND INTEREST_NAME ~ $$^[a-zA-Z0-9\s\-\']{1,50}$$ AND INTEREST_NAME !~ $$(.)\1{4,}$$
    )
);

CREATE TRIGGER TRG_TRIM_INTEREST_NAME BEFORE INSERT OR UPDATE ON INTERESTS FOR EACH ROW EXECUTE FUNCTION TRIM_INTEREST_NAME ();

CREATE TABLE IF NOT EXISTS USER_INTERESTS (
	INTEREST_ID SERIAL NOT NULL REFERENCES INTERESTS (INTEREST_ID),
	USER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	PRIMARY KEY (INTEREST_ID, USER_ID)
);

CREATE TABLE IF NOT EXISTS SWIPES (
	SWIPER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	RECEIVER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	SWIPED_AT TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
	SWIPE_TYPE T_SWIPE_TYPE NOT NULL,
	PRIMARY KEY (SWIPER_ID, RECEIVER_ID),
	CHECK (SWIPER_ID <> RECEIVER_ID)
);

CREATE OR REPLACE FUNCTION CHECK_ALLOW_MESSAGES_FROM_STRANGERS() RETURNS TRIGGER AS $$
BEGIN
    IF (SELECT allow_messages_from_strangers FROM users WHERE user_id = NEW.receiver_id) THEN RETURN NEW; END IF;
    IF EXISTS(SELECT 1 FROM swipes WHERE swiper_id = NEW.receiver_id AND receiver_id = NEW.sender_id AND swipe_type = 'like') THEN RETURN NEW; END IF;
    RAISE EXCEPTION 'Cannot message: recipient does not allow strangers and no swipe exists';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER TRG_CHECK_ALLOW_MESSAGES_FROM_STRANGERS BEFORE INSERT ON MESSAGES FOR EACH ROW EXECUTE FUNCTION CHECK_ALLOW_MESSAGES_FROM_STRANGERS();

CREATE TABLE IF NOT EXISTS PHOTOS (
	PHOTO_ID UUID PRIMARY KEY DEFAULT GEN_RANDOM_UUID(),
	UPLOADER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	IMAGE_URL VARCHAR(2083) NOT NULL UNIQUE CHECK (IMAGE_URL ~* '^https?://[^\s/$.?#].[^\s]*$'),
	IS_PRIMARY BOOLEAN NOT NULL DEFAULT FALSE
);

CREATE OR REPLACE FUNCTION check_max_photos() RETURNS TRIGGER AS $$
DECLARE photo_count INT;
BEGIN
    SELECT COUNT(*) INTO photo_count FROM photos WHERE uploader_id = NEW.uploader_id;
    IF photo_count >= 6 THEN RAISE EXCEPTION 'Cannot insert photo: a user can have a maximum of 6 photos.'; END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_max_photos BEFORE INSERT ON photos FOR EACH ROW EXECUTE FUNCTION check_max_photos();

CREATE OR REPLACE FUNCTION ENSURE_PRIMARY_ON_INSERT () RETURNS TRIGGER AS $$
DECLARE photo_count INT;
BEGIN
    SELECT COUNT(*) INTO photo_count FROM photos WHERE uploader_id = NEW.uploader_id;
    IF photo_count = 0 THEN NEW.is_primary := TRUE; END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_ENSURE_PRIMARY_ON_INSERT BEFORE INSERT ON PHOTOS FOR EACH ROW EXECUTE FUNCTION ENSURE_PRIMARY_ON_INSERT ();

CREATE OR REPLACE FUNCTION ENSURE_USER_HAS_PRIMARY () RETURNS TRIGGER AS $$
DECLARE primary_count INT;
BEGIN
    SELECT COUNT(*) INTO primary_count FROM photos WHERE uploader_id = COALESCE(NEW.uploader_id, OLD.uploader_id) AND is_primary = TRUE;
    IF primary_count = 0 THEN
        UPDATE photos SET is_primary = TRUE WHERE photo_id = (SELECT photo_id FROM photos WHERE uploader_id = COALESCE(NEW.uploader_id, OLD.uploader_id) ORDER BY photo_id DESC LIMIT 1);
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_ENSURE_PRIMARY_AFTER_UPDATE AFTER UPDATE OF IS_PRIMARY ON PHOTOS FOR EACH ROW EXECUTE FUNCTION ENSURE_USER_HAS_PRIMARY ();
CREATE TRIGGER TRG_ENSURE_PRIMARY_AFTER_DELETE AFTER DELETE ON PHOTOS FOR EACH ROW EXECUTE FUNCTION ENSURE_USER_HAS_PRIMARY ();

CREATE INDEX idx_users_demographics ON users (gender, birth_date) WHERE is_active = true;
CREATE INDEX idx_users_location ON users USING gist (ll_to_earth(latitude, longitude));
CREATE INDEX IDX_REPORTS_REPORTER ON REPORTS (REPORTER_ID);
CREATE INDEX IDX_REPORTS_REPORTED ON REPORTS (REPORTED_ID);
CREATE INDEX IDX_REPORTS_STATUS ON REPORTS (STATUS);
CREATE INDEX IDX_BLOCKS_BLOCKER ON BLOCKS (BLOCKER_ID);
CREATE INDEX IDX_BLOCKS_BLOCKED ON BLOCKS (BLOCKED_ID);
CREATE INDEX IDX_LOGINS_USER ON LOGINS (USER_ID);
CREATE INDEX IDX_LOGINS_TIME ON LOGINS (LOGGED_IN_AT);
CREATE INDEX IDX_MESSAGES_SENDER_RECEIVER ON MESSAGES (SENDER_ID, RECEIVER_ID, SENT_AT DESC);
CREATE INDEX IDX_MESSAGES_RECEIVER_SENDER ON MESSAGES (RECEIVER_ID, SENDER_ID, SENT_AT DESC);
CREATE INDEX IDX_MESSAGES_UNREAD ON MESSAGES (RECEIVER_ID, IS_READ) WHERE IS_READ = FALSE;
CREATE INDEX IDX_MESSAGES_NOT_DELETED ON MESSAGES (SENDER_ID, RECEIVER_ID, SENT_AT DESC) WHERE IS_DELETED = FALSE;
CREATE INDEX IDX_MESSAGES_NOT_DELETED_REVERSE ON MESSAGES (RECEIVER_ID, SENDER_ID, SENT_AT DESC) WHERE IS_DELETED = FALSE;
CREATE INDEX IDX_USER_INTERESTS_USER ON USER_INTERESTS (USER_ID);
CREATE INDEX IDX_USER_INTERESTS_INTEREST ON USER_INTERESTS (INTEREST_ID);
CREATE INDEX IDX_SWIPES_SWIPER ON SWIPES (SWIPER_ID);
CREATE INDEX IDX_SWIPES_RECEIVER ON SWIPES (RECEIVER_ID);
CREATE UNIQUE INDEX UX_PHOTOS_PRIMARY_PER_USER ON PHOTOS (UPLOADER_ID) WHERE IS_PRIMARY = TRUE;
CREATE INDEX IDX_PHOTOS_UPLOADER ON PHOTOS (UPLOADER_ID);

CREATE TYPE T_USER_ROLE AS ENUM('user', 'admin');
CREATE TABLE IF NOT EXISTS USER_ROLES (
    user_id UUID PRIMARY KEY REFERENCES USERS(USER_ID),
    role T_USER_ROLE NOT NULL DEFAULT 'user'
);
