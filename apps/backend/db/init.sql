CREATE EXTENSION IF NOT EXISTS CITEXT;

CREATE EXTENSION IF NOT EXISTS CUBE;

CREATE EXTENSION IF NOT EXISTS EARTHDISTANCE;

CREATE DOMAIN T_EMAIL AS CITEXT CHECK (
    VALUE ~* $$^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$$
);

CREATE TYPE T_GENDER AS ENUM('male', 'female', 'nonbinary');

CREATE TYPE T_ORIENTATION AS ENUM(
	'straight',
	'gay',
	'lesbian',
	'bisexual',
	'asexual',
	'demisexual',
	'pansexual',
	'queer',
	'questioning'
);

CREATE TYPE T_REPORT_REASON AS ENUM(
	'spam',
	'harassment',
	'fake_profile',
	'inappropriate_content',
	'scam',
	'impersonation',
	'hate_speech',
	'discrimination',
	'threats',
	'violence',
	'nudity',
	'self_harm',
	'underage_user',
	'bullying',
	'misleading_information',
	'offensive_language',
	'other'
);

CREATE TYPE T_REPORT_STATUS AS ENUM('under_review', 'dismissed', 'action_taken');

CREATE TYPE T_SWIPE_TYPE AS ENUM('like', 'dislike');

CREATE TYPE T_MESSAGE_TYPE AS ENUM ('text', 'image');

DROP FUNCTION IF EXISTS CHECK_AGE;
DROP FUNCTION IF EXISTS TRIM_USER_STRING;

CREATE OR REPLACE FUNCTION CHECK_AGE () RETURNS TRIGGER AS $$
BEGIN
    IF NEW.BIRTH_DATE > (CURRENT_DATE - INTERVAL '18 years') THEN
        RAISE EXCEPTION 'User must be at least 18 years old.';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION TRIM_USER_STRINGS () RETURNS TRIGGER AS $$
BEGIN
    IF NEW.email IS NOT NULL THEN
        NEW.email := trim(NEW.email);
    END IF;
    
    IF NEW.full_name IS NOT NULL THEN
        NEW.full_name := trim(NEW.full_name);
    END IF;
    
    IF NEW.bio IS NOT NULL THEN
        NEW.bio := trim(NEW.bio);
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TABLE IF NOT EXISTS USERS (
	USER_ID UUID PRIMARY KEY DEFAULT GEN_RANDOM_UUID(),
	EMAIL T_EMAIL NOT NULL UNIQUE,
	PASSWORD_HASH VARCHAR(255) NOT NULL,
	FULL_NAME VARCHAR(255) NOT NULL CHECK (LENGTH(FULL_NAME) > 0),
	GENDER T_GENDER NOT NULL,
	SEXUAL_ORIENTATION T_ORIENTATION NOT NULL,
	BIRTH_DATE DATE NOT NULL,
	BIO VARCHAR(512) NOT NULL DEFAULT '',
	CREATED_AT TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
	LATITUDE NUMERIC(9, 6) CHECK (LATITUDE BETWEEN -90 AND 90),
	LONGITUDE NUMERIC(9, 6) CHECK (LONGITUDE BETWEEN -180 AND 180),
	PREF_GENDERS T_GENDER[] NOT NULL,
	PREF_MIN_AGE SMALLINT NOT NULL DEFAULT 18 CHECK (PREF_MIN_AGE BETWEEN 18 AND 200),
	PREF_MAX_AGE SMALLINT NOT NULL DEFAULT 200 CHECK (PREF_MAX_AGE BETWEEN 18 AND 200),
	PREF_DISTANCE_RADIUS_KM SMALLINT NOT NULL DEFAULT 10 CHECK (PREF_DISTANCE_RADIUS_KM BETWEEN 0 AND 20000),
	IS_ACTIVE BOOL NOT NULL DEFAULT TRUE,
	ALLOW_MESSAGES_FROM_STRANGERS BOOL NOT NULL DEFAULT FALSE,
	CHECK (PREF_MIN_AGE <= PREF_MAX_AGE)
);

CREATE VIEW SAFE_USERS_PERSONAL AS
SELECT
	USER_ID,
	EMAIL,
	FULL_NAME,
	GENDER,
	SEXUAL_ORIENTATION,
	BIRTH_DATE,
	BIO,
	CREATED_AT,
	PREF_GENDERS,
	PREF_MIN_AGE,
	PREF_MAX_AGE,
	PREF_DISTANCE_RADIUS_KM,
	IS_ACTIVE,
	ALLOW_MESSAGES_FROM_STRANGERS
FROM
	USERS;

CREATE VIEW SAFE_USERS_PUBLIC AS
SELECT
	USER_ID,
	FULL_NAME,
	EXTRACT(YEAR FROM AGE(BIRTH_DATE)) AS AGE,
	SEXUAL_ORIENTATION,
	BIO
FROM
	USERS;

CREATE TRIGGER TRG_CHECK_AGE BEFORE INSERT
OR
UPDATE ON USERS FOR EACH ROW
EXECUTE FUNCTION CHECK_AGE ();

CREATE TRIGGER TRG_TRIM_USER_STRINGS BEFORE INSERT
OR
UPDATE ON USERS FOR EACH ROW
EXECUTE FUNCTION TRIM_USER_STRINGS ();

CREATE TABLE IF NOT EXISTS REPORTS (
	REPORT_ID UUID PRIMARY KEY DEFAULT GEN_RANDOM_UUID(),
	REPORTER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	REPORTED_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	REASON T_REPORT_REASON NOT NULL,
	DETAILS VARCHAR(512) NOT NULL CHECK (LENGTH(DETAILS) > 10),
	STATUS T_REPORT_STATUS NOT NULL DEFAULT 'under_review'
);

CREATE TABLE IF NOT EXISTS BLOCKS (
	BLOCKER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	BLOCKED_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	BLOCKED_AT TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
	PRIMARY KEY (BLOCKER_ID, BLOCKED_ID),
	CHECK (BLOCKER_ID <> BLOCKED_ID)
);

CREATE TABLE IF NOT EXISTS LOGINS (
	LOGIN_ID BIGSERIAL PRIMARY KEY,
	USER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	IP_ADDRESS INET NOT NULL,
	LOGGED_IN_AT TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS MESSAGES (
	MESSAGE_ID UUID PRIMARY KEY DEFAULT GEN_RANDOM_UUID(),
	SENDER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	RECEIVER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
    MESSAGE_TYPE T_MESSAGE_TYPE NOT NULL DEFAULT 'text',
	MESSAGE_CONTENT VARCHAR(1024) NOT NULL DEFAULT '',
	IS_READ BOOL NOT NULL DEFAULT FALSE,
	SENT_AT TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
	CHECK (SENDER_ID <> RECEIVER_ID)
);

DROP FUNCTION IF EXISTS TRIM_INTEREST_NAME;

CREATE OR REPLACE FUNCTION TRIM_INTEREST_NAME () RETURNS TRIGGER AS $$
BEGIN
    IF NEW.interest_name IS NOT NULL THEN
        NEW.interest_name := trim(NEW.interest_name);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TABLE IF NOT EXISTS INTERESTS (
    INTEREST_ID SERIAL PRIMARY KEY,
    INTEREST_NAME CITEXT NOT NULL UNIQUE CHECK (
        LENGTH(INTEREST_NAME) >= 2
        AND INTEREST_NAME ~ $$^[a-zA-Z0-9\s\-\']{1,50}$$
        AND INTEREST_NAME !~ $$(.)\1{4,}$$
    )
);

CREATE TRIGGER TRG_TRIM_INTEREST_NAME BEFORE INSERT
OR
UPDATE ON INTERESTS FOR EACH ROW
EXECUTE FUNCTION TRIM_INTEREST_NAME ();

CREATE TABLE IF NOT EXISTS USER_INTERESTS (
	INTEREST_ID SERIAL NOT NULL REFERENCES INTERESTS (INTEREST_ID),
	USER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	PRIMARY KEY (INTEREST_ID, USER_ID)
);

CREATE TABLE IF NOT EXISTS SWIPES (
	SWIPER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	RECEIVER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	SWIPED_AT TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
	SWIPE_TYPE T_SWIPE_TYPE NOT NULL,
	PRIMARY KEY (SWIPER_ID, RECEIVER_ID),
	CHECK (SWIPER_ID <> RECEIVER_ID)
);

CREATE OR REPLACE FUNCTION CHECK_ALLOW_MESSAGES_FROM_STRANGERS () RETURNS TRIGGER AS $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM swipes s1
        JOIN swipes s2
          ON s1.swiper_id = s2.receiver_id
         AND s1.receiver_id = s2.swiper_id
        WHERE s1.swiper_id = NEW.sender_id
          AND s1.receiver_id = NEW.receiver_id
          AND s1.swipe_type = 'like'
          AND s2.swipe_type = 'like'
    ) THEN
        RAISE EXCEPTION 'Cannot message: users have not mutually liked each other';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRG_CHECK_ALLOW_MESSAGES_FROM_STRANGERS BEFORE INSERT ON MESSAGES FOR EACH ROW
EXECUTE FUNCTION CHECK_ALLOW_MESSAGES_FROM_STRANGERS ();

CREATE TABLE IF NOT EXISTS PHOTOS (
	PHOTO_ID UUID PRIMARY KEY DEFAULT GEN_RANDOM_UUID(),
	UPLOADER_ID UUID NOT NULL REFERENCES USERS (USER_ID),
	IMAGE_URL VARCHAR(2083) NOT NULL UNIQUE CHECK (IMAGE_URL ~* '^https?://[^\s/$.?#].[^\s]*$'),
	IS_PRIMARY BOOL NOT NULL DEFAULT FALSE
);

CREATE INDEX idx_users_demographics ON users (gender, birth_date) WHERE is_active = true;

CREATE INDEX idx_users_location ON users USING gist (ll_to_earth(latitude, longitude));

CREATE INDEX IDX_REPORTS_REPORTER ON REPORTS (REPORTER_ID);

CREATE INDEX IDX_REPORTS_REPORTED ON REPORTS (REPORTED_ID);

CREATE INDEX IDX_REPORTS_STATUS ON REPORTS (STATUS);

CREATE INDEX IDX_BLOCKS_BLOCKER ON BLOCKS (BLOCKER_ID);

CREATE INDEX IDX_BLOCKS_BLOCKED ON BLOCKS (BLOCKED_ID);

CREATE INDEX IDX_LOGINS_USER ON LOGINS (USER_ID);

CREATE INDEX IDX_LOGINS_TIME ON LOGINS (LOGGED_IN_AT);

CREATE INDEX IDX_MESSAGES_SENDER_RECEIVER ON MESSAGES (SENDER_ID, RECEIVER_ID, SENT_AT DESC);

CREATE INDEX IDX_MESSAGES_RECEIVER_SENDER ON MESSAGES (RECEIVER_ID, SENDER_ID, SENT_AT DESC);

CREATE INDEX IDX_MESSAGES_UNREAD ON MESSAGES (RECEIVER_ID, IS_READ) WHERE IS_READ = FALSE;

CREATE INDEX IDX_MESSAGES_NOT_DELETED ON MESSAGES (SENDER_ID, RECEIVER_ID, SENT_AT DESC) WHERE IS_DELETED = FALSE;

CREATE INDEX IDX_MESSAGES_NOT_DELETED_REVERSE ON MESSAGES (RECEIVER_ID, SENDER_ID, SENT_AT DESC) WHERE IS_DELETED = FALSE;

CREATE INDEX IDX_USER_INTERESTS_USER ON USER_INTERESTS (USER_ID);

CREATE INDEX IDX_USER_INTERESTS_INTEREST ON USER_INTERESTS (INTEREST_ID);

CREATE INDEX IDX_SWIPES_SWIPER ON SWIPES (SWIPER_ID);

CREATE INDEX IDX_SWIPES_RECEIVER ON SWIPES (RECEIVER_ID);

CREATE UNIQUE INDEX UX_PHOTOS_PRIMARY_PER_USER ON PHOTOS (UPLOADER_ID)
WHERE
	IS_PRIMARY = TRUE;

CREATE INDEX IDX_PHOTOS_UPLOADER ON PHOTOS (UPLOADER_ID);
